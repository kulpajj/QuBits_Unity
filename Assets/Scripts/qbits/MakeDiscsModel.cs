using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MakeDiscsModel : MonoBehaviour
{
    // DESIGN MakeDiscsModel pings the ScoreDiscs script and asks for the current DiscModelParams_Cn class ( MakeDiscsModel keeps track of the current score harmony index number with a counter )
    //        ScoreDiscs makes 36 different disc model possibilities all obiding by the current DiscModelParams_Cn from the score;
    //        the MakeDiscsModel script stores all these models in a List<DiscModel_Cn>
    //        the LightDiscMovement scripts each go to MakeDiscsModel() to randomly select one of the indexes of List<DiscModel_Cn>

    // osc
    OscIn oscIn_script;

    // global evolution
    GlobalEvolution globalEvolution_script;
    GlobalEvolution.GlobalEvolutionState globalEvolutionState;
    GlobalEvolution.GlobalEvolutionState globalEvolutionStatePrev;

    // Score for discs models
    ScoreDiscs scoreDiscs;
    public DiscModelParams_Cn discModelParams;

    // mixer
    Mixer mixer;

    // mixer values
    float   mx_fund_amp;
    float   mx_fund_decay;
    Vector2 mx_partials_ampsRange;
    float   mx_partials_decay;
    Vector2 mx_harmonyDurRange_lowerAndRougher;

    InstantiateLightDiscs instantiateLightDiscs_script;
    int numDiscs;
    GameObject[] allDiscGOs;
    List<LightDiscMovement> allDiscGOs_movementScripts;
    bool firstFrame = true;

    // when to switch to a new model
    delegate void CheckIfNewModel();
    CheckIfNewModel del_checkIfNewModel;
    bool discsBusy;
    bool discsBusyPrev;
    public bool makeNewModel;
    EventRandTracker lowerAndRougher_eventRandTracker;

    // **** 
    // DESIGN this script keeps track of which DiscModelParams ( which harmony ) we are currently using from the score, thus stepping through the harmonies
    //        this script runs the ScoreDiscs class, obtaining the current DiscModel_Cn and making that model
    //        however, the LightDiscMovement()s add the beatings freqs as some part of the critical band as requested by the score
    int currentState_numHarmonies;
    int harmonyLookupIndex; // counter for lookin gup which harmony params we are on from the score

    // local DiscModelParams
    public float funds_harmonicity;
    public float funds_deformation;
    public float funds_size;
    public float funds_lowest;
    public float funds_highestAllowed;
    // deviation of the cloud of fundamentals:
    // 0. = no deviation from the funds generated by the virtual_fund 
    // > 0. is a midi number random deviation, an ever wider range of possibility
    public float funds_MIDIdeviation_range;
    public enum FundsDeviationMode { above, below, bothSides };
    // deviation allowed above, below, or on both sides of fundamental
    public FundsDeviationMode funds_MIDIdeviation_mode = FundsDeviationMode.bothSides;
    private int funds_loopCounter;

    public float parts_harmonicity;
    public float parts_deformation;
    public float parts_size;
    public float parts_highestAllowed;
    public float parts_MIDIdeviation_range;
    // 0 = no chance of including each individual partial; 1 = 100% prob of including each partial
    [ Range( 0.0f, 1.0f ) ]
    public float parts_include_prob;
    private int  parts_include_thresholdValue;
    private int  parts_include_selectedValue;
    public enum PartsDeviationMode { above, below, bothSides };
    public PartsDeviationMode parts_MIDIdeviation_mode = PartsDeviationMode.bothSides;
    private int parts_loopCounter;

    // score params just passed on to the LightDiscMovement scripts:
    public Vector2 lightFlareEvent_shimmer_percentOfCriticalBandRange;
    public DiscModelParams_Cn.ModelTransposition _modelTransposition;
    public float _ampGlobal;

    float this_fundamental;
    List<float> fundamentals_pool;
    List<float> fundamentals_discs;
    float this_deviation;

    float this_partial;

    public List<float> freqs;
    public List<float> amps;
    public List<float> decays;
    float this_amp;
    float this_decay;
    public List<DiscModel_Cn> discsModel;

    void Start() 
    {
        instantiateLightDiscs_script = GameObject.Find( "instantiateLightDiscs" ).GetComponent<InstantiateLightDiscs>();
        numDiscs = instantiateLightDiscs_script.gridX * instantiateLightDiscs_script.gridZ;

        globalEvolution_script = GameObject.Find( "globalEvolution" ).GetComponent<GlobalEvolution>();
        oscIn_script = GameObject.Find( "osc" ).GetComponent<OscIn>();
        oscIn_script.MapDouble( "/discsModel/funds_lowest", OscIn_setFundsLowest );

        scoreDiscs = new ScoreDiscs();
        scoreDiscs.CurrentHarmonyParams( globalEvolutionState, harmonyLookupIndex ); // <-- this line of code for initialization, else currentState_numHarmonies is 0 at init with divide by 0 errors
        makeNewModel = true;

        mixer = new Mixer();
        MixerValues_Init();
    }
	
	void Update() 
    {
        globalEvolutionState = globalEvolution_script.globalEvolutionState;
        EvolutionParams();
        currentState_numHarmonies = scoreDiscs.currentState_numHarmonies;

        if( firstFrame == true )
        {
            allDiscGOs = GameObject.FindGameObjectsWithTag( "disc" );
            allDiscGOs_movementScripts = new List<LightDiscMovement>();
            foreach( GameObject discGO in allDiscGOs )
            {
                allDiscGOs_movementScripts.Add( discGO.GetComponent<LightDiscMovement>() );
            }
            firstFrame = false;
        }

        del_checkIfNewModel();

        if( makeNewModel == true )
        {
            // SCORE
            GetCurrentHarmonyParamsFromScore();
            harmonyLookupIndex = ( harmonyLookupIndex + 1 ) % currentState_numHarmonies; // augment harmonyLookupIndex counter for next time around

            fundamentals_pool = new List<float>();
            fundamentals_discs = new List<float>();
            discsModel = new List<DiscModel_Cn>();

            makeNewModel = false;

            // ****************
            // pool of fundamentals that reflects model, but with no deviation yet added
            this_fundamental = funds_lowest;
            funds_loopCounter = 1;
            while( this_fundamental <= funds_highestAllowed )
            {
                // Carmine Cella's generalized series for the fundamentals' relationship across discs:
                this_fundamental = funds_lowest * ( Mathf.Pow( funds_loopCounter, funds_harmonicity ) * Mathf.Pow( funds_deformation, funds_loopCounter ) + funds_size );
                fundamentals_pool.Add( this_fundamental );
                funds_loopCounter++;
            }

            // ****************
            // we have, say, 6 at most fundamentals, but 36 discs 
            // randomly assign one to each
            for( int i = 0; i < numDiscs; i++ )
            {
                fundamentals_discs.Add( fundamentals_pool[ Random.Range( 0, fundamentals_pool.Count ) ] );
            }

            // ****************
            // randomly deviate from each fundamental according to what's requested
            for( int i = 0; i < numDiscs; i++ )
            {
                this_deviation = Random.Range( 0.0f, funds_MIDIdeviation_range );
                float midi = ftom( fundamentals_discs[ i ] );
                if( funds_MIDIdeviation_mode == FundsDeviationMode.above )
                {
                    midi += this_deviation;
                }
                else if( funds_MIDIdeviation_mode == FundsDeviationMode.below )
                {
                    midi -= this_deviation;
                }
                else if( funds_MIDIdeviation_mode == FundsDeviationMode.bothSides )
                {
                    int randomSign = Random.Range( 0, 2 ) * 2 - 1; // <---- COOL way to get a random plus or minus
                    this_deviation *= randomSign;
                    midi += this_deviation;
                }

                fundamentals_discs[ i ] = mtof( midi );
            }

            // ****************
            // from each disc / fundamental, make partials 
            for( int d = 0; d < numDiscs; d++ )
            {
                freqs =  new List<float>();
                amps =   new List<float>();
                decays = new List<float>();

                this_fundamental = fundamentals_discs[ d ];
                this_partial = 0;

                freqs.Add( this_fundamental );
                amps.Add( mx_fund_amp );
                decays.Add( mx_fund_decay );

                parts_loopCounter = 2;
                parts_include_thresholdValue = Mathf.RoundToInt( Scale( parts_include_prob, 0.0f, 1.0f, 0, 1999 ) );
                while( this_partial <= parts_highestAllowed )
                {
                    // ****************
                    // whether to even include this partial
                    parts_include_selectedValue = Random.Range( 0, 2000 );
                    if( parts_include_selectedValue <= parts_include_thresholdValue )
                    {
                        // the generalized series for the partials' relationships within a disc:
                        this_partial = this_fundamental * ( Mathf.Pow( parts_loopCounter, parts_harmonicity ) * Mathf.Pow( parts_deformation, parts_loopCounter ) + parts_size );

                        // ****************
                        // randomly deviate from each partial according to what's requested
                        this_deviation = Random.Range( 0.0f, parts_MIDIdeviation_range );
                        float midi = ftom( this_partial );
                        if( parts_MIDIdeviation_mode == PartsDeviationMode.above )
                        {
                            midi += this_deviation;
                        }
                        else if( parts_MIDIdeviation_mode == PartsDeviationMode.below )
                        {
                            midi -= this_deviation;
                        }
                        else if( parts_MIDIdeviation_mode == PartsDeviationMode.bothSides )
                        {
                            int randomSign = Random.Range( 0, 2 ) * 2 - 1;
                            this_deviation *= randomSign;
                            midi += this_deviation;
                        }

                        freqs.Add( mtof( midi ) );
                        amps.Add( Random.Range( mx_partials_ampsRange[0], mx_partials_ampsRange[1] ) );
                        decays.Add( mx_partials_decay );

                        parts_loopCounter++;
                    }
                }

                // discsModel is a list of the class DiscModel with as many entries as there are lightdiscs on the ceiling
                // so discsModel is a class containing, e.g. 36, soundsrandomly baked according to the desired Generalized Series
                // in addition, each lightdisc GO randomly selects which of these entries to play when they are stuck by a geyser
                discsModel.Add( new DiscModel_Cn { freqs = freqs, amps = amps, decays = decays, modelTransposition = _modelTransposition, ampGlobal = _ampGlobal } ); 
            }
        }

        discsBusyPrev = discsBusy;
        globalEvolutionStatePrev = globalEvolutionState;
    }

    // SCORE
    void GetCurrentHarmonyParamsFromScore()
    {
        discModelParams = scoreDiscs.CurrentHarmonyParams( globalEvolutionState, harmonyLookupIndex );

        funds_harmonicity         = discModelParams.funds_harmonicity;
        funds_deformation         = discModelParams.funds_deformation;
        funds_size                = discModelParams.funds_size;
        funds_lowest              = discModelParams.funds_lowest;
        funds_highestAllowed      = discModelParams.funds_highestAllowed;
        funds_MIDIdeviation_range = discModelParams.funds_MIDIdeviation_range;
        parts_harmonicity         = discModelParams.parts_harmonicity;
        parts_deformation         = discModelParams.parts_deformation;
        parts_size                = discModelParams.parts_size;
        parts_highestAllowed      = discModelParams.parts_highestAllowed;
        parts_MIDIdeviation_range = discModelParams.parts_MIDIdeviation_range;
        parts_include_prob        = discModelParams.parts_include_prob;
        lightFlareEvent_shimmer_percentOfCriticalBandRange = discModelParams.lightFlareEvent_shimmer_percentOfCriticalBandRange;
        _modelTransposition       = discModelParams.modelTransposition;
        _ampGlobal                = discModelParams.ampGlobal;

        Debug.Log( "index " + harmonyLookupIndex + " lowest " + funds_lowest );
    }

    //******************************
    // mixer values
    void MixerValues_Init()
    {
        mx_fund_amp                        = mixer.model_fund_amp;
        mx_fund_decay                      = mixer.model_fund_decay;
        mx_partials_ampsRange              = mixer.model_partials_ampsRange;
        mx_partials_decay                  = mixer.model_partials_decay;
        mx_harmonyDurRange_lowerAndRougher = mixer.model_harmonyDurRange_lowerAndRougher;
    }

    //******************************
    // OscIn
    void OscIn_setFundsLowest( double fund )
    {
        funds_lowest = (float)fund;
        makeNewModel = true;
    }

    //******************************
    // delegates
    void CheckIfNewModel_BeginCeiling()
    {
        // ****
        // new model when all ceiling lightDiscs aren't busy
        discsBusy = false;
        foreach( LightDiscMovement discScript in allDiscGOs_movementScripts )
        {
            if( discScript.busyFlare == true )
            {
                discsBusy = true;
                break;
            }
        }

        // make a new model each time we transition from discs were busy (sounding), and now they are not
        if( discsBusy == false && discsBusyPrev == true )
        {
            makeNewModel = true;
        }
    }

    void CheckIfNewModel_LowerAndRougher()
    {
        // ****
        // new model when eventRandTracker says so - just steps through the harmmonies until we get to the end of the score
        makeNewModel = lowerAndRougher_eventRandTracker.Return_EventStartClick( mx_harmonyDurRange_lowerAndRougher );
    }

    //******************************
    // ><>  ><>  ><>  ><>
    void EvolutionParams()
    { 
        if( globalEvolutionState == GlobalEvolution.GlobalEvolutionState.begin || globalEvolutionState == GlobalEvolution.GlobalEvolutionState.beginCeiling || globalEvolutionState == GlobalEvolution.GlobalEvolutionState.beginSpin || globalEvolutionState == GlobalEvolution.GlobalEvolutionState.tallerTubes )
        {
            del_checkIfNewModel = CheckIfNewModel_BeginCeiling;
        }
        else if( globalEvolutionState == GlobalEvolution.GlobalEvolutionState.lowerAndRougher )
        {
            if( globalEvolutionStatePrev != GlobalEvolution.GlobalEvolutionState.lowerAndRougher && globalEvolutionState == GlobalEvolution.GlobalEvolutionState.lowerAndRougher )
            {
                lowerAndRougher_eventRandTracker = new EventRandTracker();
                harmonyLookupIndex = 0; // reset the counter; begin at the first harmony
            }
            del_checkIfNewModel = CheckIfNewModel_LowerAndRougher;
        }
    }

    //******************************
    // etc
    float ftom( float freq )
    {
        float midi = 69 + 12 * Mathf.Log( freq / 440, 2);

        return midi;
    }

    float mtof( float midi )
    {
        float freq = Mathf.Pow( 2, ( midi - 69 ) / 12 ) * 440;

        return freq;
    }

    float Scale( float oldValue, float oldMin, float oldMax, float newMin, float newMax )
    {

        float oldRange = oldMax - oldMin;
        float newRange = newMax - newMin;
        float newValue = (((oldValue - oldMin) * newRange) / oldRange) + newMin;

        return newValue;
    }
}
